import java.util.Scanner;		//IMPORTAR SCANNER

/**
 * @author UO281827
 * 		ENUNCIADO 1: EN UN TABLERO DE AJEDREZ REDUCIDO DE 5X5. SI SE COLOCA UN GRANO DE TRIGO EN LA PRIMERA CASILLA, EN LA SEGUNDA DOS,
 * 					EN LA TERCERA CUATRO ETC ETC.... ¿CUÁNTOS GRANOS HAY EN LA ÚLTIMA CASILLA? NO UTILIZAR LA FUNCIÓN MATH.POW(A,B).
 * 
 * 		ENUNCIADO 2: EN UNA SECUENCIA DE COMO MÍNIMO 3 NÚMEROS NATURALES TERMINADA EN NEGATIVO INTRODUCIDA POR EL USUARIO, DEVOLVER SI HAY O NO UN VALLE.
 * 				VALLE: UN NÚMERO DE LA SECUENCIA ES MENOR AL ANTERIOR Y AL SIGUIENTE. EJEMPLO: (2 1 3) UNO ES MENOR QUE DOS Y QUE TRES.
 *
 */
public class EL2UO281827 {

	public static void main(String[] args) {
		Scanner teclado = new Scanner (System.in);		//CREA TECLADO
		
//-----------EJERCICIO 1--------------
		int trigo=1;		//GRANOS INICIALES
		for (int i=1;i<=25;i++) {		//PARA 25 VECES
			trigo=trigo*2;		//DUPLICAR CANTIDAD
		}
		System.out.printf("El número de granos de trigo totales es: %d.\n", trigo);		//OUTPUT
		
//------------EJERCICIO 2--------------
		int n=0;		//SECUENCIA
		int anterior=0;			//ANTERIOR
		int siguiente=0;		//SIGUIENTE
		int contador=0;			//CONTADOR - DEBEMOS SABER CUÁNDO LLEGA A 3 NÚMEROS.
		
		System.out.print("Secuencia de naturales (finaliza con un negativo): ");		//SOLICITA SECUENCIA
		
		/* EXPLICACIÓN BUCLE:
		 * TENEMOS 4 VARIABLES: N 			(VALOR CENTRAL DE LA EVALUACIÓN)
		 * 						ANTERIOR 	(VALOR ANTERIOR DE LA EVALUACIÓN)	
		 * 						SIGUIENTE 	(VALOR SIGUIENTE DE LA EVALUACIÓN)
		 * 						CONTADOR	(CUENTA LA EVALUACIÓN QUE ESTAMOS HACIENDO. SÓLO NOS SIRVE PARA CONDICIONAR A PARTIR DEL TERCER VALOR)
		 * 
		 * CONDICIÓN WHILE:
		 * 		LAS DOS PRIMERAS VUELTAS NO SON EVALUACIONES VÁLIDAS YA QUE NO HEMOS LEÍDO 3 NÚMEROS TODAVÍA.
		 * 		PARA QUE ESTA SITUACIÓN NO ESTROPEE EL BUCLE, AÑADIMOS AL WHILE UNA CONDICIÓN (CONTADOR<3)
		 * 		DE ESTA FORMA, EL BUCLE SE REPETIRÁ LAS 3 PRIMERAS VECES SIN IMPORTAR SI SE CUMPLEN O NO LAS CONDICIONES DE VALLE.
		 * 
		 * 				HASTA AHORA, CONDICIÓN DEL WHILE: (CONTADOR<3 || (CONDICION VALLE))
		 * 
		 * 
		 * 		EN CUANTO SE ENCUENTRE UN VALOR MENOR QUE 0, LA SECUENCIA HABRÁ FINALIZADO Y DEBEREMOS CERRAR EL BUCLE.
		 * 		AÑADIMOS ESTA CONDICIÓN.
		 * 
		 * 				HASTA AHORA, CONDICIÓN DEL WHILE: (CONTADOR<3 || (N>0 && (CONDICION VALLE)))
		 * 
		 * 
		 * 		LAS CONDICIONES PARA QUE UN GRUPO DE 3 NÚMEROS COMO (ANTERIOR, N, SIGUIENTE) SEAN VALLE ES:
		 * 				N<ANTERIOR && N<SIGUIENTE
		 * 		PARA APLICARLAS AL BUCLE WHILE TENEMOS QUE INVERTIRLAS: ¬(N<ANTERIOR && N<SIGUIENTE) ==> (APLICANDO LAS LEYES DE DE MORGAN) ==>
		 * 		==> N>ANTERIOR || N>SIGUIENTE
		 * 		AÑADIMOS AL WHILE EN (CONDICIÓN VALLE)
		 * 		
		 * 				FINAL, CONDICIÓN DEL WHILE: (CONTADOR<3 || (N>ANTERIOR || N>SIGUIENTE))
		 * 
		 * 
		 * FUNCIONAMIENTO BUCLE:
		 * 		EL CONTADOR SE ACTUALIZA
		 * 
		 * 		EL  ANTERIOR ES EL ACTUAL DE LA ANTERIOR VUELTA
		 * 		EL ACTUAL ES EL SIGUIENTE DE LA ANTERIOR VUELTA
		 * 		EL SIGUIENTE ES EL NEXTINT() DE LA SECUENCIA
		 * 
		 * 		(EVALUACIÓN DE CONDICIONES)
		 * 
		 */
		
		do {		//BUCLE
			contador++;			//ACTUALIZAR CONTADOR
			anterior=n;			//VALOR ANTERIOR
			n = siguiente;		//VALOR ACTUAL
			siguiente = teclado.nextInt();		//VALOR SIGUIENTE
		} while (contador<3 || (siguiente>0 && (n>anterior || n>siguiente)));		//CONDICIÓN
				//CONTADOR MÍNIMO 3 Y CONDICIÓN DE VALLE	
		
		
		if (n<anterior && n<siguiente) {		//SI (CONDICIÓN PARA VALLE)
			System.out.printf("Hay un valle en la secuencia: (%d,%d,%d)." , anterior,n,siguiente);		//OUTPUT
		} else {		//SI NO (NO HAY VALLE)
			System.out.print("No hay valles.");		//OUTPUT
		}
	}
}
